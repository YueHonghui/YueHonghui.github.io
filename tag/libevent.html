<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <title>光明顶 - libevent</title>
        <link rel="stylesheet" href="/theme/css/main.css" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">光明顶 </a></h1>
                <nav><ul>
                    <li><a href="/category/kai-fa.html">开发</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/notes_of_libevent.html">libevent使用注意事项</a></h1>
<footer class="post-info">
        <abbr class="published" title="2013-10-03T10:20:00">
                Thu 03 October 2013
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="/author/hhyue.html">hhyue</a>
        </address>
<p>In <a href="/category/kai-fa.html">开发</a>. </p>
<p>tags: <a href="/tag/libevent.html">libevent</a><a href="/tag/assert.html">assert</a></p>
</footer><!-- /.post-info --><p>之前的项目中使用了libevent作为事件发生器, 在使用的过程中, 发生了好多次程序的测试时进入了死循环. 通过发信号中断其运行, 并保存backtrace, 断定死循环发生在libevent的内部loop中. 经过多番排查, 猜测可能是struct event没有初始化, 便进行了event_add操作, 或者是进行了多次event_add和event_del. 翻看libevent源码, 发现当event_set, event_add, event_del调用序列如果不对, 会弄乱libevent内部结构.</p>
<p>为了彻底防止这种非法调用序列的发生, 写了一个libevent的包装层, 针对常用的几个api, 自己做了层状态守护, 一旦发现非法调用序列, 立即assert.</p>
<p>合法调用序列如下:</p>
<div class="highlight"><pre><span class="c1">//event</span>
<span class="n">event_set</span><span class="o">-&gt;</span><span class="n">event_set</span><span class="p">;</span>
<span class="n">event_set</span><span class="o">-&gt;</span><span class="n">event_add</span><span class="p">;</span>
<span class="n">event_add</span><span class="o">-&gt;</span><span class="n">event_del</span><span class="p">;</span>
<span class="n">event_del</span><span class="o">-&gt;</span><span class="n">event_set</span><span class="p">;</span>

<span class="c1">//timer</span>
<span class="n">evtimer_set</span><span class="o">-&gt;</span><span class="n">evtimer_set</span><span class="p">;</span>
<span class="n">evtimer_set</span><span class="o">-&gt;</span><span class="n">evtimer_add</span><span class="p">;</span>
<span class="n">evtimer_add</span><span class="o">-&gt;</span><span class="n">evtimer_del</span><span class="p">;</span>
<span class="n">evtimer_del</span><span class="o">-&gt;</span><span class="n">evtimer_set</span>
<span class="n">evtimer_add</span><span class="o">-&gt;</span><span class="n">timeout</span>
<span class="n">timeout</span><span class="o">-&gt;</span><span class="n">evtimer_set</span><span class="p">;</span>
</pre></div>


<p>以上调用序列中, 完全禁止timer的event操作使用event_set, event_add, event_del等 操作, 只允许使用evtimer系列操作. 这是与libevent原有的api定义不符的, 其原有定义中timer的event是可以混用这两组api的. 为什么这样子做? 这是因为在实现这个包装层的时候, 我一直在想libevent库的api实现为什么不做这么一种状态守护, 发现非法操作时, 不是默默地接受, 而是拒绝执行(assert? 返回错误码?). 在一番尝试之后, 发现timer的event的操作的这种"灵活的选择性"成了实现这个包装层的阻碍, 无法找到办法去跟踪这种调用路径.直到去掉了这种灵活性后, 选择上面的那组合法调用序列, 包装层很快就完成了. 个人认为这是libevent的api设计的一个ugly的地方, 自作聪明地为干一件事情提供了多种"灵活的选择", 正确的做法应该是干一件事情, 有且只有一种最合适的做法.</p>
<p>如预料的, 在提供了这层包装层后, 便发现了多个非法调用序列, 在清理完这些调用序列后, 就再也没有发生类似的死循环事件. 在这件事中, 虽然保证合法的调用序列本来就应该是调用者的责任, 但如果提供健壮的非法调用序列侦测机制, 便可以大大提高正确性和生产效率. 如非必要, 应禁止为了所谓的灵活性而牺牲api的简单和单义性.</p>                </article>
<p class="paginator">
    Page 1 / 1
</p>
            </aside><!-- /#featured -->
            </ol><!-- /#posts-list -->
            </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>blogroll</h2>
                        <ul>
                            <li><a href="http://getpelican.com/">Pelican</a></li>
                            <li><a href="http://python.org/">Python.org</a></li>
                            <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>