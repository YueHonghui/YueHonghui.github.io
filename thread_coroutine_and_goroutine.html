<!DOCTYPE html>
<html lang="zh">

  <head>
    <title>光明顶</title>
    <link href="http://yui.yahooapis.com/3.17.2/build/cssreset/cssreset-min.css" rel="stylesheet"/>
    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/webfont/1.3.0/webfont.js"></script>
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"/>

<link href='/theme/css/prettify.css' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="/theme/js/Markdown.Converter.js"></script>
<script type="text/javascript" src="/theme/js/Markdown.Extra.js"></script>
<script type="text/javascript" src="/theme/js/prettify.js"></script>
<script type="text/javascript">
        $(document).ready(function () {
            var converter = new Markdown.Converter();
            Markdown.Extra.init(converter, {
                extensions: "all",
                highlighter: "prettify"
                });
            var rawcontent = "## 调度方式\u000A我们将线程/进程、gevent的coroutine、golang中的goroutine中执行实体逻辑上统称为task。一个task从运行到挂起状态转换有两种方式，一种是**抢占式**，对应的，另一种是**非抢占式**(或称作**协作式**)。操作系统中的task调度兼具这两种方式，如task的时间片用完，或者有更高优先级的task就绪，调度器就会强行将当前task挂起，将执行权让度给其它task\u003B 若task在用户空间主动调用了sleep，那么就会主动出让CPU。而coroutine和goroutine的调度器，“一般”都只有非抢占式调度，在task不主动调用或间接调用switch及schedule等动作时，调度器无法中止当前task的执行，如果当前task阻塞，就会将调度器一并阻塞。\u000A## 抢占式vs非抢占式\u000A对于用户空间的代码而言，这两种调度方式各有优缺点。\u000A抢占式调度的优点很明显，可以防止一个task引起所有task的阻塞。因为赋予了调度器主动挂起task的能力，所以也可以对调度器作更多的优化。但其缺点也很明显，因为无法预知何时会被抢占，task无法准确知道挂起会发生在代码的哪一行。\u000A相反，非抢占式调度的调度效果受制于task自身，如果task长期占用CPU，或者发生阻塞，就会影响其它task的执行，调度器无法干预。但对于task而言，可以准确预知挂起点会发生在代码的哪几行(如进行了switch操作或者io操作)，在这些挂起点之间的代码片断一定不会发生挂起。\u000A## 对并发的影响\u000A对task并发的讨论，可以构造两组场景。一组是多线程与单线程下的多coroutine；另一组是单线程环境下的多coroutine与多线程环境下的多goroutine。\u000A\u000A第一组场景中，多线程环境无疑是最为复杂的，因为既存在并发也存在并行(多核CPU)。由于操作系统对多线程有抢占式调度能力，task也无法预知代码的挂起点。这种特点的后果就是，如果有资源共享，将无法避免资源的竞争，只要对资源有访问，就需要使用同步手段。单线程下的多coroutine则虽然没有并行，但仍有并发的特点，同时由于非抢占式调度，task可以预知挂起点。这意味着，对共享资源的访问，只要没有跨越挂起点，就不会发生竞争，则无需使用同步手段！这是非常大的好处，无论是对性能还是对程序员的思维负担而言。现在流行的单线程事件回调式编程也受益于同样的道理。\u000A\u000A第二组场景，与单线程下的多coroutine相比，由于可以利用多个CPU，多线程环境下的多goroutine实际上也具有并发和并行的特点，且task可能跨多线程，挂起点也无法预知。所以，在不恰当的设计下，资源共享正好发生在可能跨多个线程的多个goroutine时，资源竞争将会退化到多线程相同的局面，性能和思维的成本也会急剧地上升，仅有的好处，只剩下用户空间的task调度成本小于内核态的多线程调度而已。\u000A## 并行的实践建议\u000A在gevent中，如果想利用多核实现并行，一般是运行多个gevent进程，进程间再利用消息通信来实现状态的同步。这种设计模式强迫使用者仔细思考业务需求，将资源与状态小心切分，将同步频度小的资源与状态放到不同的进程中。**这样的好处是，虽然进程间通信成本很高，但通过合理的规划，通信频度降到最低，进程间通信总体成本仍然可控；进程内部虽然共享频度高，但可以利用进程内共享成本低以及coroutine可以将资源竞争降到很低的优点，提高资源及状态共享的效率。** golang可以在一个进程中用多线程实现并行，且多线程间资源及状态共享成本低于多进程，但也要仔细审查这种特性所带来的坏处。多线程打破了多进程间强保证的资源隔离状态，也引入了不可预知的task挂起，在使用时，需要更小心的权衡和克制。golang新的版本中还引入了有限的抢占式调度能力(在函数调用的边界)，不知道这个变化是利是弊。\u000A\u000A**这里面的关键点是，减少资源的竞争，一种是task隔离，一种是利用可预知的挂起。**\u000A";
            var ohtml = converter.makeHtml(rawcontent);
            $('.article').append(ohtml);
            prettyPrint();
        });
</script>

    <link rel="stylesheet" type="text/css" href="./theme/css/styles.css"/>
      <meta charset="utf-8" />
  </head>

  <body id="index">
    <!-- header -->
    <header class="siteheader">
      <!-- site image -->

      <div class = "sitebanner">
        <h1><a class="sitetitle nodec" href=".">光明顶</a></h1>
        <h3 class ="sitesubtitle"></h3>
        <!-- nav -->
        <nav class="menu">
          <ul>
            <!-- menu items-->
            <!--pages-->
            <!-- services icons -->
              <li><a class="fa fa-github-alt fa-lg" href="https://github.com/YueHonghui"></a></li>
              <li><a class="fa fa-bitbucket fa-lg" href="https://bitbucket.org/YueHonghui"></a></li>
          </ul>
        </nav>
      </div> <!-- sitebanner -->
    </header>

    <!-- content -->

<section class="content">

  <h3 class="posttitle">
    <a class="nodec" href="/thread_coroutine_and_goroutine.html" rel="bookmark" title="Permalink to 线程、coroutine与goroutine">
      线程、coroutine与goroutine
    </a>
  </h3>

  <div class="postinfo">
    <p class="published" title="2014-09-18T22:50:32">
      2014-09-18 22:50:32
    </p>

  </div><!-- .postinfo -->

  <div class="article">
  </div><!-- .content -->
</section>


    <!-- footer -->
    <footer>
      <p>
        © hhyue, license <a href=""> </a>
        unless otherwise noted.
        Generated by <a href= "http://docs.getpelican.com/">Pelican</a> with
        <a href="http://github.com/porterjamesj/crowsfoot">crowsfoot</a> theme.
      </p>
    </footer>
  </body>
</html>